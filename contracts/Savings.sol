// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";
import "./ISwapProxy.sol";

contract Savings is AutomationCompatible {

    struct TokenDistribution {
      address token;
      uint256 amount;
    }

    address public immutable owner;
    ISwapProxy swapProxy;
    address public constant WETH = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6;     

    address[] public whitelistTokens;
    TokenDistribution[] tokenDistribution;

    modifier onlyOwner {
      require(msg.sender == owner, "Only owner can call this function");
      _;
    }

    constructor(ISwapProxy _swapProxy, address[] memory _whitelistTokens, TokenDistribution[] memory _tokenDistribution) {
      owner = msg.sender;
      swapRouter = _swapRouter;
      whitelistTokens = _whitelistTokens;

      for (uint256 x = 0; x < _tokenDistribution.length; x++) {
        tokenDistribution[x] = _tokenDistribution[x];
      }
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = address(this).balance > 0;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        uint256 amount = address(this).balance;

        //We highly recommend revalidating the upkeep in the performUpkeep function
        if (address(this).balance > 0) {
          for (uint256 x = 0; x < tokenDistribution.length; x++) {
            uint256 amount = balance * tokenDistribution[x].amount / 100;
            if (tokenDistribution[x].token == address(0)) {
              (bool sent, ) = owner.call{value: amount}("");
              require(sent, "Failed to send ether");
            }
            else {
              swapProxy.swapExactInputSingle{value: amount}(amount, WETH, tokenDistribution[x].token, owner);
            }
          }
          // for (int x = 0; x < tokenDistribution.length; x++) {
            
          // }
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    function emergencyWithdraw() external {
      (bool sent, ) = owner.call{value: address(this).balance}("");
      require(sent, "Failed to send ether");
    }

    fallback() external payable {} 
    receive() external payable {} 
}
